<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Climb+ â€” Refined Hill Climb Game</title>
  <style>
    body, html { margin:0; padding:0; height:100%; background:#0a0f1f; color:#eee; font:16px sans-serif; }
    #stage { position:relative; width:100%; height:400px; max-width:900px; margin:auto; background:#0b1025; overflow:hidden; }
    .overlay, .btn, .hud, .touchpad { /* minimal styling, for brevity */ }
    #overlay { position:absolute; inset:0; background:rgba(0,0,0,0.7); display:flex; align-items:center; justify-content:center; color:#fff; }
    #overlay.hidden { display:none; }
    #hud { position:absolute; bottom:10px; right:10px; background:rgba(0,0,0,0.5); padding:6px; border-radius:4px; }
    .hud { color:#0f0; }
  </style>
</head>
<body>
  <div id="stage">
    <div id="overlay">
      <div>
        <h2>Tap Start to Drive</h2>
        <button id="startBtn">Start</button>
      </div>
    </div>
    <div id="hud">Distance: <span id="dist">0 m</span></div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js"></script>
  <script type="module">
    import { createNoise2D } from 'https://cdn.jsdelivr.net/npm/simplex-noise@4.0.3/+esm';
    const { Engine, Render, Runner, World, Bodies, Body, Constraint, Events } = Matter;

    // Basic tuning
    const SEG_W = 60, AMP = 100, SCALE = 0.003;
    const carSetting = { x:100, y:200, wheelR:20, axle:50, torque:0.001, spring:{len:20, stiff:0.6, damp:0.25} };

    const engine = Engine.create({ gravity:{ x:0, y:1.2 } });
    const render = Render.create({ element:document.getElementById('stage'), engine, options:{ width:900, height:400, wireframes:false, background:'#0b1025' }});
    Render.run(render); Runner.run(Runner.create(), engine);

    // Terrain generation
    const noise2D = createNoise2D(), ground = [];
    let maxX = -SEG_W*2;
    function addTerrain(xTo) {
      for(let x = maxX; x < xTo; x += SEG_W) {
        const y0 = 350 - (noise2D(x*SCALE,0)*AMP);
        const y1 = 350 - (noise2D((x+SEG_W)*SCALE,0)*AMP);
        const tri = Bodies.fromVertices(x + SEG_W/2, 0, [
          {x:x, y:y0}, {x:x+SEG_W, y:y1}, {x:x+SEG_W, y:400}, {x:x, y:400}
        ], { isStatic:true, render:{ fillStyle:'#0e172d' }}, true);
        World.add(engine.world, tri);
        ground.push(tri);
      }
      maxX = xTo;
    }
    addTerrain(800);

    // Car creation
    function makeCar(x, y) {
      const group = Body.nextGroup(true);
      const chassis = Bodies.rectangle(x, y, 100, 20, { collisionFilter:{ group }, render:{ fillStyle:'#22d3ee' }});
      const wl = Bodies.circle(x - carSetting.axle, y + 20, carSetting.wheelR, { collisionFilter:{ group }, friction:0.9, render:{ fillStyle:'#94a3b8' }});
      const wr = Bodies.circle(x + carSetting.axle, y + 20, carSetting.wheelR, { collisionFilter:{ group }, friction:0.9, render:{ fillStyle:'#94a3b8' }});
      const sl = Constraint.create({ bodyA:chassis, pointA:{x:-carSetting.axle,y:10}, bodyB:wl, length:carSetting.spring.len, stiffness:carSetting.spring.stiff, damping:carSetting.spring.damp });
      const sr = Constraint.create({ bodyA:chassis, pointA:{x:carSetting.axle,y:10}, bodyB:wr, length:carSetting.spring.len, stiffness:carSetting.spring.stiff, damping:carSetting.spring.damp });
      World.add(engine.world, [chassis, wl, wr, sl, sr]);
      return { chassis, wl, wr };
    }
    const car = makeCar(carSetting.x, carSetting.y);

    // Camera follow & distance
    const distSpan = document.getElementById('dist');
    Events.on(engine, 'afterUpdate', () => {
      addTerrain(car.chassis.position.x + 400);
      distSpan.textContent = Math.floor((car.chassis.position.x - carSetting.x)) + ' m';
      Render.lookAt(render, car.chassis, { x: render.options.width/2, y: render.options.height/2 });
    });

    // Controls
    const keys = { left:false, right:false };
    window.addEventListener('keydown', e => { if(e.code==='ArrowRight') keys.right=true; if(e.code==='ArrowLeft') keys.left=true; });
    window.addEventListener('keyup', e => { if(e.code==='ArrowRight') keys.right=false; if(e.code==='ArrowLeft') keys.left=false; });
    Events.on(engine, 'beforeUpdate', () => {
      if(keys.right) Body.applyTorque(car.wl, carSetting.torque), Body.applyTorque(car.wr, carSetting.torque);
      if(keys.left) Body.applyTorque(car.wl, -carSetting.torque), Body.applyTorque(car.wr, -carSetting.torque);
    });

    // Start and overlay handling
    const overlay = document.getElementById('overlay');
    document.getElementById('startBtn').onclick = () => overlay.classList.add('hidden');

  </script>
</body>
</html>

