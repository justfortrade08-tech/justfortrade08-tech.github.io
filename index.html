<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dodge ‚Äî HTML5 Game</title>
  <meta name="description" content="A tiny HTML5 game. Use arrows/WASD or touch controls to dodge the blocks!">
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='128' height='128'%3E%3Ctext y='1em' font-size='96'%3EüéÆ%3C/text%3E%3C/svg%3E">
  <style>
    :root{
      --bg:#0f172a;      /* slate-900 */
      --panel:#111827;   /* gray-900 */
      --muted:#94a3b8;   /* slate-400 */
      --text:#e2e8f0;    /* slate-200 */
      --accent:#22d3ee;  /* cyan-400 */
      --accent-2:#a78bfa;/* violet-400 */
      --danger:#fb7185;  /* rose-400 */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font:16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background: radial-gradient(1200px 600px at 10% -10%, #1f2937 0, #0b1025 60%, #070a16 100%) fixed, var(--bg);
    }
    header{
      position:sticky; top:0; z-index:10;
      background:linear-gradient(180deg, rgba(17,24,39,.9), rgba(17,24,39,.6));
      backdrop-filter: blur(6px);
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .wrap{max-width:1000px; margin:0 auto; padding:16px}
    .row{display:flex; align-items:center; gap:12px; justify-content:space-between}
    .brand{display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.3px}
    .pill{
      border:1px solid rgba(255,255,255,.12); color:var(--text);
      padding:8px 12px; border-radius:999px; text-decoration:none; display:inline-flex; gap:8px; align-items:center;
    }
    .pill:hover{border-color:rgba(255,255,255,.24)}
    main{padding:24px 16px 64px}
    .hero{
      display:grid; grid-template-columns:1.1fr .9fr; gap:20px; align-items:center;
    }
    @media (max-width:900px){ .hero{grid-template-columns:1fr} }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius:20px; padding:16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05);
    }
    h1{font-size:32px; margin:6px 0 8px}
    p{color:var(--muted); margin:0 0 14px}
    .cta{display:flex; gap:10px; flex-wrap:wrap}
    .btn{
      background:linear-gradient(90deg, var(--accent), var(--accent-2));
      color:#0b1025; font-weight:700; border:0; padding:10px 14px; border-radius:12px; cursor:pointer;
      box-shadow:0 8px 20px rgba(34,211,238,.25);
    }
    .btn.secondary{background:transparent; color:var(--text); border:1px solid rgba(255,255,255,.14)}
    .stats{display:flex; gap:14px; flex-wrap:wrap; margin-top:6px; color:var(--muted)}
    .stat{padding:6px 10px; border:1px dashed rgba(255,255,255,.14); border-radius:999px}
    /* Game panel */
    .game-wrap{position:relative; aspect-ratio:16/10; width:100%; max-width:680px; margin-inline:auto; border-radius:16px; overflow:hidden;
      border:1px solid rgba(255,255,255,.08); background:linear-gradient(180deg, #0b1025, #0a0e21);}
    canvas{display:block; width:100%; height:100%; image-rendering:pixelated}
    .overlay{
      position:absolute; inset:0; display:flex; align-items:center; justify-content:center; text-align:center;
      background:linear-gradient(180deg, rgba(2,6,23,.55), rgba(2,6,23,.25)); backdrop-filter: blur(2px);
      padding:20px;
    }
    .overlay.hidden{display:none}
    .panel{
      max-width:520px; width:100%; padding:18px; border-radius:16px;
      background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.12)
    }
    .panel h2{margin:0 0 8px}
    .kbd{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.2)}
    .hud{
      position:absolute; inset:auto 12px 12px auto; display:flex; gap:10px; align-items:center; color:#d1fae5;
      background:rgba(6,78,59,.3); border:1px solid rgba(16,185,129,.35); padding:6px 10px; border-radius:10px
    }
    .pause{right:12px; top:12px; left:auto; bottom:auto; background:rgba(2,6,23,.5); border:1px solid rgba(255,255,255,.15)}
    /* Mobile touch pad */
    .touchpad{
      position:absolute; left:8px; bottom:8px; display:grid; grid-template-columns:repeat(3,56px);
      gap:8px; opacity:.85; user-select:none
    }
    .tpbtn{
      width:56px; height:56px; border-radius:12px; border:1px solid rgba(255,255,255,.15);
      background:rgba(255,255,255,.06); display:grid; place-items:center; font-weight:700; color:var(--text)
    }
    @media (min-width:900px){ .touchpad{display:none} }
    footer{padding:32px 16px; border-top:1px solid rgba(255,255,255,.08); color:var(--muted); text-align:center}
  </style>
</head>
<body>
  <header>
    <div class="wrap row">
      <div class="brand">üéÆ <span>Dodge</span></div>
      <nav class="row" style="gap:8px">
        <a class="pill" href="#play">Play</a>
        <a class="pill" href="#how">How to play</a>
        <a class="pill" href="#about">About</a>
      </nav>
    </div>
  </header>

  <main class="wrap">
    <section class="hero">
      <div class="card">
        <h1>Survive. Score. Set a high score.</h1>
        <p>Dodge moving blocks. Works on keyboard and touch. Lightweight, no downloads.</p>
        <div class="cta">
          <a class="btn" href="#play">‚ñ∂ Play now</a>
          <button class="btn secondary" id="resetHigh">Reset high score</button>
        </div>
        <div class="stats">
          <span class="stat">High score: <strong id="hiA">0</strong></span>
          <span class="stat">FPS: <strong id="fps">0</strong></span>
          <span class="stat">Pause: <span class="kbd">P</span> ‚Ä¢ Restart: <span class="kbd">R</span></span>
        </div>
      </div>
      <div class="card" id="play">
        <div class="game-wrap" id="gameWrap">
          <canvas id="game" width="800" height="500"></canvas>
          <div class="hud" id="hud">Score: <strong id="score">0</strong></div>
          <button class="hud pause" id="pauseBtn">‚è∏</button>

          <div class="touchpad" id="touchpad">
            <div></div> <button class="tpbtn" data-dir="up">‚Üë</button> <div></div>
            <button class="tpbtn" data-dir="left">‚Üê</button> <div></div> <button class="tpbtn" data-dir="right">‚Üí</button>
            <div></div> <button class="tpbtn" data-dir="down">‚Üì</button> <div></div>
          </div>

          <div class="overlay" id="overlay">
            <div class="panel">
              <h2>Tap ‚ÄúStart‚Äù to play</h2>
              <p>Move with <span class="kbd">WASD</span> / <span class="kbd">‚Üë‚Üê‚Üì‚Üí</span> or touch arrows. Avoid red blocks.</p>
              <div class="cta" style="margin-top:10px">
                <button class="btn" id="startBtn">Start</button>
                <button class="btn secondary" id="howBtn">How to play</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="how" class="card" style="margin-top:20px">
      <h2>How to play</h2>
      <ul>
        <li>Move the circle to dodge incoming blocks.</li>
        <li>Score increases over time. Collide = game over.</li>
        <li><strong>Keyboard:</strong> WASD / Arrow keys. <strong>Pause:</strong> P. <strong>Restart:</strong> R.</li>
        <li><strong>Touch:</strong> Use on-screen arrows.</li>
      </ul>
    </section>

    <section id="about" class="card" style="margin-top:20px">
      <h2>About this site</h2>
      <p>Built with plain HTML5 Canvas + JavaScript. No frameworks. Hosted free on GitHub Pages.</p>
    </section>
  </main>

  <footer>¬© <span id="year"></span> Your Game</footer>

  <script>
    const $ = s => document.querySelector(s);
    const scoreEl = $("#score"), hiElA = $("#hiA"), fpsEl = $("#fps");
    const overlay = $("#overlay"), startBtn = $("#startBtn"), howBtn = $("#howBtn");
    const resetHigh = $("#resetHigh"), pauseBtn = $("#pauseBtn"); $("#year").textContent = new Date().getFullYear();

    const canvas = $("#game"), ctx = canvas.getContext("2d");
    let running=false, paused=false, last=0, acc=0, spawn=0, fpsSmoothed=0;

    const S = {
      w: canvas.width,
      h: canvas.height,
      player:{x:120, y:250, r:12, speed:260},
      vel:{x:0,y:0},
      keys:{},
      obstacles:[],
      score:0,
      hi: +localStorage.getItem("dodge_hi") || 0
    };
    hiElA.textContent = S.hi;

    function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }
    function rnd(a,b){ return Math.random()*(b-a)+a; }

    function reset(){
      S.player.x=120; S.player.y=250; S.vel.x=0; S.vel.y=0;
      S.obstacles.length=0; S.score=0; spawn=0; acc=0;
      overlay.classList.add("hidden"); running=true; paused=false;
    }

    function spawnObs(){
      const h = rnd(20, 80);
      const y = rnd(10, S.h-10-h);
      const speed = rnd(180, 320);
      S.obstacles.push({x:S.w+20, y, w:rnd(18,26), h, vx:-speed, color:"#fb7185"});
    }

    function circleRectCollide(cx,cy,cr, rx,ry,rw,rh){
      const nx = clamp(cx, rx, rx+rw);
      const ny = clamp(cy, ry, ry+rh);
      const dx = cx - nx, dy = cy - ny;
      return dx*dx + dy*dy < cr*cr;
    }

    function draw(){
      // background
      const g = ctx.createLinearGradient(0,0,0,S.h);
      g.addColorStop(0,"#0b1025"); g.addColorStop(1,"#090e22");
      ctx.fillStyle=g; ctx.fillRect(0,0,S.w,S.h);

      // player
      ctx.beginPath();
      ctx.arc(S.player.x, S.player.y, S.player.r, 0, Math.PI*2);
      ctx.fillStyle="#22d3ee"; ctx.fill();

      // obstacles
      for(const o of S.obstacles){
        ctx.fillStyle=o.color;
        ctx.fillRect(o.x, o.y, o.w, o.h);
      }

      // border glow
      ctx.strokeStyle="rgba(167,139,250,.6)";
      ctx.lineWidth=2; ctx.strokeRect(1,1,S.w-2,S.h-2);
    }

    function update(dt){
      // input
      const k=S.keys;
      const ax = (k["ArrowRight"]||k["KeyD"]?1:0) - (k["ArrowLeft"]||k["KeyA"]?1:0);
      const ay = (k["ArrowDown"] ||k["KeyS"]?1:0) - (k["ArrowUp"]  ||k["KeyW"]?1:0);
      S.vel.x = ax * S.player.speed;
      S.vel.y = ay * S.player.speed;

      // move
      S.player.x = clamp(S.player.x + S.vel.x*dt, S.player.r, S.w - S.player.r);
      S.player.y = clamp(S.player.y + S.vel.y*dt, S.player.r, S.h - S.player.r);

      // spawn & move obstacles
      spawn -= dt;
      if (spawn <= 0){ spawn = Math.max(.25, 1.2 - S.score/40); spawnObs(); }
      for(const o of S.obstacles){ o.x += o.vx * dt; }
      // prune off-screen
      S.obstacles = S.obstacles.filter(o => o.x + o.w > -40);

      // collisions
      for(const o of S.obstacles){
        if (circleRectCollide(S.player.x,S.player.y,S.player.r, o.x,o.y,o.w,o.h)){
          gameOver(); return;
        }
      }

      // score
      S.score += dt*10;
      scoreEl.textContent = Math.floor(S.score);
    }

    function loop(t){
      if(!running){ return; }
      const dt = Math.min(0.033, (t-last)/1000 || 0); last=t;

      if(!paused){
        update(dt);
        draw();
        // fps
        const fps = 1/dt;
        fpsSmoothed = fpsSmoothed ? fpsSmoothed*0.9 + fps*0.1 : fps;
        fpsEl.textContent = Math.round(fpsSmoothed);
      }
      requestAnimationFrame(loop);
    }

    function gameOver(){
      running=false;
      const sc = Math.floor(S.score);
      if (sc > S.hi){ S.hi=sc; localStorage.setItem("dodge_hi", S.hi); hiElA.textContent=S.hi; }
      overlay.querySelector("h2").textContent = "Game over!";
      overlay.querySelector("p").innerHTML = `Score: <strong>${sc}</strong> ‚Ä¢ High: <strong>${S.hi}</strong>`;
      overlay.classList.remove("hidden");
    }

    // input
    addEventListener("keydown", e=>{
      if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
      S.keys[e.code]=true;
      if(e.code==="KeyP"){ paused=!paused; pauseBtn.textContent = paused?"‚ñ∂":"‚è∏"; }
      if(e.code==="KeyR"){ overlay.classList.add("hidden"); reset(); last=performance.now(); requestAnimationFrame(loop); }
    });
    addEventListener("keyup", e=>{ S.keys[e.code]=false; });

    // touch pad
    document.querySelectorAll(".tpbtn").forEach(btn=>{
      const dir = btn.dataset.dir;
      const map = {up:"ArrowUp",down:"ArrowDown",left:"ArrowLeft",right:"ArrowRight"};
      const code = map[dir];
      const set = (v)=>{ S.keys[code]=v; };
      ["touchstart","mousedown"].forEach(ev=>btn.addEventListener(ev, e=>{ e.preventDefault(); set(true);} ));
      ["touchend","mouseup","mouseleave","touchcancel"].forEach(ev=>btn.addEventListener(ev, ()=>set(false)));
    });

    // UI wiring
    startBtn.addEventListener("click", ()=>{ reset(); last=performance.now(); requestAnimationFrame(loop); });
    howBtn.addEventListener("click", ()=>location.hash="#how");
    pauseBtn.addEventListener("click", ()=>{ paused=!paused; pauseBtn.textContent = paused?"‚ñ∂":"‚è∏"; });
    resetHigh.addEventListener("click", ()=>{ localStorage.removeItem("dodge_hi"); S.hi=0; hiElA.textContent=0; });

    // keep canvas crisp on resize
    const wrap = document.getElementById("gameWrap");
    function fit(){
      // maintain internal resolution but make CSS size responsive (handled by CSS). No action needed.
    }
    addEventListener("resize", fit); fit();
  </script>
</body>
</html>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Climb+ ‚Äî HTML5 Physics Hill Climber</title>
<meta name="description" content="A refined 2D hill-climb game. Physics car, springy suspension, infinite noise terrain, mobile controls.">
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Ctext y='1em' font-size='96'%3Eüöô%3C/text%3E%3C/svg%3E">
<style>
  :root{
    --bg:#0a0f1f; --panel:#0f172a; --ink:#e5e7eb; --muted:#9ca3af;
    --accent:#22d3ee; --accent2:#a78bfa; --danger:#fb7185; --ok:#34d399;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0; color:var(--ink); background:
    radial-gradient(1200px 600px at 10% -20%, #1c2544 0, #0a0f1f 60%) fixed, var(--bg);
    font:16px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;}
  header{position:sticky; top:0; z-index:5; backdrop-filter: blur(8px);
    background:linear-gradient(180deg, rgba(15,23,42,.9), rgba(15,23,42,.5));
    border-bottom:1px solid rgba(255,255,255,.06)}
  .wrap{max-width:1100px; margin:0 auto; padding:14px 16px}
  .row{display:flex; align-items:center; justify-content:space-between; gap:12px}
  .brand{display:flex; gap:10px; align-items:center; font-weight:800}
  .pill{display:inline-flex; align-items:center; gap:8px; padding:8px 12px;
    border:1px solid rgba(255,255,255,.14); border-radius:999px; color:inherit; text-decoration:none}
  .pill:hover{border-color:rgba(255,255,255,.28)}
  main{padding:20px 16px 40px}
  .grid{display:grid; grid-template-columns:1.1fr .9fr; gap:16px}
  @media (max-width:960px){ .grid{grid-template-columns:1fr} }
  .card{background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.08); border-radius:20px; padding:16px;
    box-shadow:0 10px 30px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05)}
  .cta{display:flex; flex-wrap:wrap; gap:10px}
  .btn{border:0; padding:10px 14px; border-radius:12px; font-weight:700; cursor:pointer}
  .btn.primary{background:linear-gradient(90deg, var(--accent), var(--accent2)); color:#0a0f1f}
  .btn.secondary{background:transparent; color:var(--ink); border:1px solid rgba(255,255,255,.14)}
  .stats{display:flex; flex-wrap:wrap; gap:12px; color:var(--muted); margin-top:8px}
  .stat{padding:6px 10px; border:1px dashed rgba(255,255,255,.16); border-radius:999px}
  .game-wrap{position:relative; border-radius:16px; overflow:hidden;
    border:1px solid rgba(255,255,255,.08); background:#0b1025}
  /* Canvas is created by Matter; we size its container. */
  #stage{aspect-ratio:16/9; width:100%; max-width:900px; margin:0 auto; display:block}

  /* HUD */
  .hud{position:absolute; right:12px; bottom:12px; display:flex; gap:10px; align-items:center;
    background:rgba(2,6,23,.45); border:1px solid rgba(255,255,255,.18); padding:6px 10px; border-radius:12px}
  .hud strong{color:var(--ok)}
  .pause{position:absolute; right:12px; top:12px; background:rgba(2,6,23,.45);
    border:1px solid rgba(255,255,255,.18); padding:6px 10px; border-radius:10px; color:var(--ink)}
  .overlay{position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg, rgba(2,6,23,.55), rgba(2,6,23,.25)); backdrop-filter: blur(2px)}
  .panel{max-width:520px; width:100%; padding:18px; border-radius:16px;
    background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03)); border:1px solid rgba(255,255,255,.12)}
  .kbd{padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.24); font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}

  /* Mobile controls */
  .touchpad{position:absolute; left:8px; bottom:8px; display:grid; grid-template-columns:repeat(3,64px); gap:8px; user-select:none; opacity:.9}
  .tpbtn{width:64px; height:64px; border-radius:14px; border:1px solid rgba(255,255,255,.15);
    background:rgba(255,255,255,.06); color:var(--ink); font-weight:800}
  @media (min-width:900px){ .touchpad{display:none} }
  footer{padding:28px 16px; text-align:center; color:var(--muted)}
</style>
</head>
<body>
<header>
  <div class="wrap row">
    <div class="brand">üöô <span>Climb+</span></div>
    <nav class="row" style="gap:8px">
      <a class="pill" href="#play">Play</a>
      <a class="pill" href="#how">How</a>
      <a class="pill" href="#tuning">Tuning</a>
    </nav>
  </div>
</header>

<main class="wrap">
  <section class="grid">
    <div class="card">
      <h1>Climb+, a refined hill-climb game</h1>
      <p>Springy suspension, torque control, and endless, noise-based terrain. Works on keyboard and touch.</p>
      <div class="cta">
        <a class="btn primary" href="#play">‚ñ∂ Play</a>
        <button class="btn secondary" id="resetBtn">Reset best time</button>
      </div>
      <div class="stats">
        <span class="stat">Best distance: <strong id="best">0 m</strong></span>
        <span class="stat">FPS: <strong id="fps">0</strong></span>
        <span class="stat">Controls: <span class="kbd">‚Üê/‚Üí</span> throttle ‚Ä¢ <span class="kbd">‚Üë/‚Üì</span> pitch ‚Ä¢ <span class="kbd">P</span> pause</span>
      </div>
    </div>

    <div id="play" class="card game-wrap">
      <!-- Matter will inject a canvas into this div -->
      <div id="stage"></div>
      <button class="pause" id="pauseBtn">‚è∏</button>
      <div class="hud">Distance: <strong id="dist">0 m</strong></div>

      <!-- Touch controls -->
      <div class="touchpad" id="touchpad">
        <div></div><button class="tpbtn" data-dir="up">‚Üë</button><div></div>
        <button class="tpbtn" data-dir="left">‚Üê</button><div></div><button class="tpbtn" data-dir="right">‚Üí</button>
        <div></div><button class="tpbtn" data-dir="down">‚Üì</button><div></div>
      </div>

      <!-- Start overlay -->
      <div class="overlay" id="overlay">
        <div class="panel">
          <h2>Tap ‚ÄúStart‚Äù to drive</h2>
          <p>Throttle with <span class="kbd">‚Üí</span>, brake <span class="kbd">‚Üê</span>, pitch your car with <span class="kbd">‚Üë/‚Üì</span>. Reach as far as you can.</p>
          <div class="cta" style="margin-top:10px">
            <button class="btn primary" id="startBtn">Start</button>
            <button class="btn secondary" id="howBtn">How to play</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <section id="how" class="card" style="margin-top:18px">
    <h2>How to play</h2>
    <ul>
      <li>Accelerate with <strong>Right Arrow</strong>, brake/reverse with <strong>Left Arrow</strong>.</li>
      <li>Use <strong>Up/Down</strong> to pitch the car mid-air for better landings.</li>
      <li>Drive as far as possible without flipping. Your best distance is saved locally.</li>
    </ul>
  </section>

  <section id="tuning" class="card" style="margin-top:18px">
    <h2>Tuning</h2>
    <p>Open the code and tweak the <code>TUNE</code> object (spring stiffness/damping, torque, wheel size). Changes hot-reload on refresh.</p>
  </section>
</main>

<footer>¬© <span id="year"></span> Climb+</footer>

<!-- Physics engine (global 'Matter') -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js" integrity="sha512-+F3oGvC5p3QweP5m8y17Q6vGAO2qE5u4l09w5qQ1zI9mUKX6nWPqZl1Y3HhQJf2lqC5xUydxHZo3YkcnFjMtxg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<!-- Noise (ES module import) -->
<script type="module">
import { createNoise2D } from 'https://cdn.jsdelivr.net/npm/simplex-noise@4.0.3/+esm';

const {
  Engine, Render, Runner, World, Bodies, Body, Composite, Constraint, Common, Events, Vertices
} = window.Matter;

// ---------------------- Config / Tuning ----------------------
const TUNE = {
  world: { g: 1.1 },               // gravity
  segmentW: 60,                     // width of each terrain segment (px)
  noiseScale: 0.0025,               // lower = smoother hills
  noiseAmp: 140,                    // hill amplitude (px)
  car: {
    x: 100, y: 200,
    wheelR: 26, axleOffset: 55,     // distance between wheels
    torque: 0.0016,                 // motor torque (apply to wheels)
    pitchTorque: 0.0009,            // torque applied to chassis with ‚Üë/‚Üì
    chassis: { w: 120, h: 30, density: 0.0018, friction: 0.3, restitution: 0.0 },
    wheel:   { density: 0.0025, friction: 0.9, restitution: 0.1 },
    spring:  { length: 18, stiffness: 0.56, damping: 0.24 } // refined, spring-y but stable
  }
};

// ---------------------- Engine / Render ----------------------
const engine = Engine.create({ gravity: { x: 0, y: TUNE.world.g }});
const stage = document.getElementById('stage');
const render = Render.create({
  element: stage,
  engine,
  options: {
    width: 1024, height: 576,
    background: 'linear-gradient(180deg, #0b1025, #0a0e21)',
    wireframes: false, pixelRatio: window.devicePixelRatio || 1,
    showPerformance: false
  }
});
Render.run(render);
const runner = Runner.create();
Runner.run(runner, engine);
document.getElementById('year').textContent = new Date().getFullYear();

// ---------------------- Terrain (endless) ----------------------
const noise2D = createNoise2D(); // seeded internally; change to createNoise2D(RandomSeed) if needed
const groundBodies = [];
let terrainXMax = -Infinity;

const WORLD_FLOOR = render.options.height - 40; // base line
function terrainY(x){
  return WORLD_FLOOR - (noise2D(x * TUNE.noiseScale, 0) * TUNE.noiseAmp + 60);
}

function addTerrainUntil(targetX){
  const step = TUNE.segmentW;
  let startX = (groundBodies.length ? terrainXMax : -step*2);
  if (startX < -step) startX = -step;
  for (let x = startX; x < targetX + 800; x += step){
    const x0 = x, x1 = x + step;
    const y0 = terrainY(x0), y1 = terrainY(x1);
    // Build a polygon that fills downwards (prevents falling through gaps)
    const poly = [
      {x:x0, y:y0}, {x:x1, y:y1}, {x:x1, y:10000}, {x:x0, y:10000}
    ];
    const ground = Bodies.fromVertices(x0 + step/2, 0, [poly], {
      isStatic: true,
      friction: 0.9,
      render: { fillStyle: '#0e172d', strokeStyle: 'rgba(167,139,250,.35)', lineWidth: 1 }
    }, true);
    World.add(engine.world, ground);
    groundBodies.push(ground);
    terrainXMax = x1;
  }
}

// ---------------------- Car (chassis + 2 wheels + springs) ----------------------
function makeCar(x, y){
  // Put all parts in the same negative group -> they won't collide with each other
  const group = Body.nextGroup(true); // negative group, see Matter docs
  const ch = Bodies.rectangle(x, y, TUNE.car.chassis.w, TUNE.car.chassis.h, {
    density: TUNE.car.chassis.density,
    friction: TUNE.car.chassis.friction,
    restitution: TUNE.car.chassis.restitution,
    chamfer: { radius: 10 },
    collisionFilter: { group },
    render: { fillStyle: '#22d3ee' }
  });
  const wR = TUNE.car.wheelR;
  const axle = TUNE.car.axleOffset;

  const wl = Bodies.circle(x - axle, y + 10, wR, {
    density: TUNE.car.wheel.density,
    friction: TUNE.car.wheel.friction,
    restitution: TUNE.car.wheel.restitution,
    collisionFilter: { group },
    render: { fillStyle: '#94a3b8' }
  });
  const wr = Bodies.circle(x + axle, y + 10, wR, {
    density: TUNE.car.wheel.density,
    friction: TUNE.car.wheel.friction,
    restitution: TUNE.car.wheel.restitution,
    collisionFilter: { group },
    render: { fillStyle: '#94a3b8' }
  });

  // Suspension via constraints (springs with damping)
  const sL = Constraint.create({
    bodyA: ch, pointA: { x: -axle, y: 12 },
    bodyB: wl, pointB: { x: 0, y: 0 },
    length: TUNE.car.spring.length, stiffness: TUNE.car.spring.stiffness, damping: TUNE.car.spring.damping,
    render: { strokeStyle: 'rgba(255,255,255,.3)' }
  });
  const sR = Constraint.create({
    bodyA: ch, pointA: { x: axle, y: 12 },
    bodyB: wr, pointB: { x: 0, y: 0 },
    length: TUNE.car.spring.length, stiffness: TUNE.car.spring.stiffness, damping: TUNE.car.spring.damping,
    render: { strokeStyle: 'rgba(255,255,255,.3)' }
  });

  World.add(engine.world, [ch, wl, wr, sL, sR]);
  return { ch, wl, wr };
}

const car = makeCar(TUNE.car.x, TUNE.car.y);

// ---------------------- Controls ----------------------
const keys = { left:false, right:false, up:false, down:false };
function setKey(code, down){
  if (code==='ArrowLeft' || code==='KeyA') keys.left = down;
  if (code==='ArrowRight'|| code==='KeyD') keys.right = down;
  if (code==='ArrowUp'   || code==='KeyW') keys.up = down;
  if (code==='ArrowDown' || code==='KeyS') keys.down = down;
  if (code==='KeyP' && down){ togglePause(); }
}
addEventListener('keydown', e=>{ if (e.code.startsWith('Arrow')) e.preventDefault(); setKey(e.code,true); });
addEventListener('keyup',   e=> setKey(e.code,false) );

document.querySelectorAll('.tpbtn').forEach(btn=>{
  const map = {up:'ArrowUp',down:'ArrowDown',left:'ArrowLeft',right:'ArrowRight'};
  const code = map[btn.dataset.dir];
  btn.addEventListener('mousedown', ()=>setKey(code,true));
  btn.addEventListener('mouseup',   ()=>setKey(code,false));
  btn.addEventListener('mouseleave',()=>setKey(code,false));
  btn.addEventListener('touchstart',(e)=>{e.preventDefault(); setKey(code,true);});
  btn.addEventListener('touchend',  (e)=>{e.preventDefault(); setKey(code,false);});
});

// ---------------------- Camera follow ----------------------
const cam = { x: 0, y: 0 };
function updateCamera(){
  const targetX = car.ch.position.x + 220;
  const targetY = car.ch.position.y - 60;
  cam.x += (targetX - cam.x) * 0.08;
  cam.y += (targetY - cam.y) * 0.08;

  const halfW = render.options.width/2;
  const halfH = render.options.height/2;
  render.bounds.min.x = cam.x - halfW;
  render.bounds.max.x = cam.x + halfW;
  render.bounds.min.y = cam.y - halfH;
  render.bounds.max.y = cam.y + halfH;
  Render.lookAt(render, render.bounds);
}

// ---------------------- Game loop: inputs/forces/HUD ----------------------
const distEl = document.getElementById('dist');
const bestEl = document.getElementById('best');
const fpsEl = document.getElementById('fps');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const overlay = document.getElementById('overlay');
const startBtn = document.getElementById('startBtn');
const howBtn = document.getElementById('howBtn');
document.getElementById('year').textContent = new Date().getFullYear();

let running = false, paused = false, lastT = 0, fpsSmoothed = 0;
let best = +localStorage.getItem('climb_best') || 0;

function togglePause(){
  paused = !paused;
  pauseBtn.textContent = paused ? '‚ñ∂' : '‚è∏';
}
pauseBtn.addEventListener('click', togglePause);
resetBtn.addEventListener('click', ()=>{ best=0; localStorage.setItem('climb_best', '0'); bestEl.textContent = '0 m'; });

startBtn.addEventListener('click', ()=>{ overlay.style.display='none'; running = true; });
howBtn.addEventListener('click', ()=> location.hash = '#how');

Events.on(engine, 'beforeUpdate', () => {
  if (!running || paused) return;

  // Ensure terrain exists ahead
  addTerrainUntil(car.ch.position.x + 600);

  // Wheel torque control
  const torque = TUNE.car.torque;
  if (keys.right) { Body.setAngularVelocity(car.wl, car.wl.angularVelocity + torque); Body.setAngularVelocity(car.wr, car.wr.angularVelocity + torque); }
  if (keys.left)  { Body.setAngularVelocity(car.wl, car.wl.angularVelocity - torque); Body.setAngularVelocity(car.wr, car.wr.angularVelocity - torque); }

  // Pitch control (rotate chassis slightly in air)
  if (keys.up)   Body.setAngularVelocity(car.ch, car.ch.angularVelocity - TUNE.car.pitchTorque);
  if (keys.down) Body.setAngularVelocity(car.ch, car.ch.angularVelocity + TUNE.car.pitchTorque);
});

// Simple ‚Äúdeath‚Äù if upside-down for a while
let upsideTimer = 0;
Events.on(engine, 'afterUpdate', (e) => {
  if (!running || paused) return;

  const angle = Math.abs(car.ch.angle % (Math.PI*2));
  const upside = (angle > Math.PI/2 && angle < Math.PI*1.5);
  upsideTimer = upside ? upsideTimer + e.delta : Math.max(0, upsideTimer - e.delta*2);
  if (upsideTimer > 1400){ // ~1.4s upside-down
    running = false;
    overlay.querySelector('h2').textContent = 'You flipped!';
    overlay.querySelector('p').innerHTML = `Distance: <strong>${meters(distanceTravelled())}</strong> ‚Ä¢ Best: <strong>${meters(best)}</strong>`;
    overlay.style.display = 'flex';
  }

  updateCamera();

  // HUD: distance & FPS
  const d = distanceTravelled();
  if (d > best){ best = d; localStorage.setItem('climb_best', String(best)); }
  distEl.textContent = meters(d);
  bestEl.textContent = meters(best);

  const dt = (e.timestamp - lastT) || 16.7; lastT = e.timestamp;
  const fps = 1000/dt; fpsSmoothed = fpsSmoothed? fpsSmoothed*0.9 + fps*0.1 : fps;
  fpsEl.textContent = Math.round(fpsSmoothed);
});

function meters(px){ return Math.floor(px/30) + ' m'; }
function distanceTravelled(){ return Math.max(0, car.ch.position.x - TUNE.car.x); }

// Spawn initial ground
addTerrainUntil(1200);

// Niceties: world boundaries far below
const floor = Bodies.rectangle(0, 10040, 40000, 100, { isStatic:true, render:{visible:false}});
World.add(engine.world, floor);

// Start visible if user presses any driving key
addEventListener('keydown', () => { if (!running){ overlay.style.display='none'; running=true; }}, { once:false });
</script>

</body>
</html>
